```yaml
problem: '잃어버린 괄호'
tags: 수학, 그리디, 문자열, 파싱
difficulty: silver2
source: baekjoon
link: https://www.acmicpc.net/problem/1541
```

### title : [PS][S2][.py] 잃어버린 괄호 ( TIL 24 04 25 )

# problem

`0-9`까지의 숫자와 와 `+`, `-`로 이루어진 문자열이 주어진다.

이 문자열에 적절한 괄호를 쳐서, 연산의 결과가 최소고 되도록 하시오.

# 🤔

문제는 어떤 알고리즘을 구현하는 것 보다는 의미를 잘 파악하는 것이 중요해 보인다.

## 괄호의 의미

우선 괄호를 친다는게 어떤 뜻일지를 보자.

$$
A + B + ... \Rightarrow A + (B + ...) 
$$

이것을 각각의 경우로 나눠서 성질을 파악해보자.

### + 의 경우

$$
A + B + C + ...
$$

와 같이 모든 연산기호가 `+`인 경우를 생각해보자.

$$
A + (B + C + ... ) = A + B + C + ...
$$

**+의 경우는 의미가 없다.**

뒤에 어떤 기호가 와도 그대로고 자기 자신 또한 그 모습을 유지한다.

### - 의 경우

작게 시작하자. -가 있는 숫자 뒤에 하나의 숫자만 있는 경우다.

$$
A - B + C \Rightarrow A - (B + C) = A - B - C
$$

$$
A - B - C \Rightarrow A - (B - C) = A - B + C
$$

`-`를 괄호를 치게 되면, 자기 자신의 값은 변화를 하지 않는다.
하지만 괄호의 대상의 되는 숫자들의 연산기호는 변화하게 된다.

## 최소값을 구하는 방법

- 문제의 정의에 따라, 모든 숫자, `A, B, C, D, ...`는 `0-9`사이의 숫자다.
- `+`에 괄호를 치는것 의미가 없다. $\Rightarrow$ 무시하자.
- `-`에 괄호를 치면, 자기 자신은 그대로, 괄호에 포함된 모든 문자의 연산기호를 변화시킨다.

문제 조건은 최소값을 구하는 것이다.

따라서, `-`가 최대가 된다면, 연산 결과가 최소가 된다.
이를 위해서, 괄호를 `-`에만 치되, 뒤에는 `+`인 숫자만 포함시켜, `+`를 `-`로 바꾸는 것이다.

$$
A - B + C - D + E \Rightarrow A - (B) + C - (D + E) 
$$

위와 같이, 문제를 해결하기 위한 방법은 다음과 같다.

1. 모든 `-` 뒤에서 괄호를 연다.
2. `-` 부호를 만나면, 괄호를 닫는다

> **탐욕법**이다. 부분에서의 좋은 선택이 전체에서의 좋은 선택을 만든다고 보장 할 수 있다.

이를 통해 일반화된 결과는 다음과 같을 것이다.

$$
(A + ... + B) - (C + ... + D ) - (E + ... + F) - (G + ...) - ...
$$

## 구현하기

1. 입력 받은 문자열을 `-`를 기준으로 나눈다.
2. 나누어진 그룹 내부의 값을 모두 더한다.
3. 결과 값에 첫 그룹의 총합을 더한다.
  - (문제 기준에 문자열의 첫 시작은 숫자라는 조건이 있다. 첫 그룹은 유일한 `+` 그룹이다,)
4. 나머지 모든 그룹의 결과를 결과 값에서 빼준다.

# solution w/code

설명이라고 하기도 애매한게 위의 구현을 그대로 옮긴것이다.

우선, 문자열을 `-`를 기준을 쪼갠다.

```python
input().split("-")
```

쪼갠 각 요소를리스트 컴프리헨션으로 하나씩 순회하면서, 함수의 결과값을 저장할 것이다.

```python
[for numbers in input().split("-") ]
```

쪼갠 요소들을 다시 `+`로 쪼개고, `numbers.split("+")`
전부 숫자로 바꿔주고, `map(int, numbers.split("+"))`
다 더해준다. `sum(map(int, numbers.split("+")))`

그러면 다음과  같은 리스트 컴프리헨션이 가능하다.

```python
[sum(map(int, numbers.split("+"))) for numbers in input().split("-")]
```

이제 가장 앞의 원소만 결과에 더하고, 나머지들은 전부 빼줘야 한다.
리스트를 구조분해 할당하기 위해서 `*`를 사용할 것이다.

> ### 파이선에서 구조 분해 할당
>파이선에서 구조 분해 할당을 할 때는 분해된 원소를 받기 위한 변수가 과하면 당연히 안되지만, 모자라도 안된다. 
>그런 경우 **가능한 많이 반복**하여, 모자란 나머지를 채우기 위해 `*`를 사용한다.
>`*`를 찍으면 가능한 많이 반복한다. 
>따라서 다음과 같이 할당이 된다.
>```python
>list  = [1,2,3,4,5,6,7]
>a, b = list  # error
>a, *b = list
>print(a)  # 1
>print(b)  # [2, 3, 4, 5, 6, 7]
>```
>b가 **가능한 많이 반복해서** 나머지 모든 원소를 가져 오게 된다.


가장 앞의 원소만 `first`로 할당하고 나머지는 `rest`에 전부 저장해 주기 

```python
first,*rest = [sum(map(int, numbers.split("+"))) for numbers in input().split("-")]
```

그러면 이제 `answer = 0` 로 선언하고, `answer = answer + first - sum(rest)`를 하면 될까?
괜히 변수 할당하지 말자. 일회용이고, 꼭 필요하지 않은 변수는 굳이 사용하지 않는게 좋다고 본다.

```python
print(first - sum(rest))
```

# review : 🙂

## 🔥🔥.5 & ⌛: 40 min

문제의 난이도 보다는 시간을 잡아먹었다.
그리디라는 생각보다, 수학적으로 일반화 하려고 했다.
그리디로 접근했으면 쉬웠을것 같은데, 아직도 뇌가 충분히 알고리즘적으로 돌아가지 않는것 같다.

# code
 
```python
first,*rest = [sum(map(int, numbers.split("+"))) for numbers in input().split("-")]
print(first - sum(rest))
```