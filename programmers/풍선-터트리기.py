"""
###### 문제 설명

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1.  임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2.  터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

---

##### 제한 사항

-   a의 길이는 1 이상 1,000,000 이하입니다.
    -   `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
    -   a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
    -   a의 모든 수는 서로 다릅니다.

---

##### 입출력 예

| a | result |
| --- | --- |
| `[9,-1,-5]` | 3 |
| `[-16,27,65,-2,58,-92,-71,-68,-61,-33]` | 6 |

---

##### 입출력 예 설명

입출력 예 #1

-   첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1.  `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2.  `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
-   두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1.  `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2.  `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
-   세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1.  `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2.  `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
-   3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

입출력 예 #2

-   최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.
"""

def solution(balloons):

    answer = 0

    # 순회, from left
    minimum = float('inf')
    left_min_arr = []

    for balloon in balloons:
        if balloon < minimum:
            minimum = balloon
        left_min_arr.append(minimum)

    # 순회, from right
    minimum = float('inf')
    right_min_arr = []

    for balloon in balloons[::-1]:
        if  balloon < minimum:
            minimum = balloon
        right_min_arr.append(minimum)
    right_min_arr.reverse()

    # 풍선 확인
    for idx, balloon in enumerate(balloons):
        if balloon <= left_min_arr[idx] or balloon <= right_min_arr[idx]:
            answer += 1
    return answer

""" use enumerate
 테스트 1 〉	통과 (0.01ms, 10.2MB)
 테스트 2 〉	통과 (0.01ms, 10.2MB)
 테스트 3 〉	통과 (0.50ms, 10.4MB)
 테스트 4 〉	통과 (29.25ms, 16.7MB)
 테스트 5 〉	통과 (168.20ms, 44.4MB)
 테스트 6 〉	통과 (258.35ms, 59.8MB)
 테스트 7 〉	통과 (337.10ms, 76.7MB)
 테스트 8 〉	통과 (384.63ms, 76.7MB)
 테스트 9 〉	통과 (394.34ms, 76.8MB)
테스트 10 〉	통과 (320.07ms, 76.7MB)
테스트 11 〉	통과 (344.46ms, 76.6MB)
테스트 12 〉	통과 (382.18ms, 76.7MB)
테스트 13 〉	통과 (337.86ms, 76.7MB)
테스트 14 〉	통과 (318.33ms, 76.7MB)
테스트 15 〉	통과 (325.90ms, 76.7MB)
"""

""" use for - in
 테스트 1 〉	통과 (0.01ms, 10.3MB)
 테스트 2 〉	통과 (0.01ms, 10.2MB)
 테스트 3 〉	통과 (0.42ms, 10.3MB)
 테스트 4 〉	통과 (49.50ms, 16.7MB)
 테스트 5 〉	통과 (126.95ms, 44.2MB)
 테스트 6 〉	통과 (203.92ms, 59.8MB)
 테스트 7 〉	통과 (295.72ms, 76.7MB)
 테스트 8 〉	통과 (266.98ms, 76.8MB)
 테스트 9 〉	통과 (310.61ms, 76.8MB)
테스트 10 〉	통과 (279.29ms, 76.7MB)
테스트 11 〉	통과 (262.78ms, 76.8MB)
테스트 12 〉	통과 (281.61ms, 76.7MB)
테스트 13 〉	통과 (303.05ms, 76.7MB)
테스트 14 〉	통과 (292.11ms, 76.7MB)
테스트 15 〉	통과 (332.77ms, 76.6MB)

"""